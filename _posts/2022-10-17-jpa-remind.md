---
layout: post
title: 프로젝트에서 jpa를 사용하면서 느낀것들
date: 2022-10-17 20:00
tags: db jpa remind optimization
description:
---

### jpa 와 jdbc, jpa를 사용하면서 전반적으로 느낀것들

- 이전 프로젝트에서는 be에서 직접 jdbc를 사용하여, 프로젝트 개발을 하였다.
- 쿼리를 문자열로 작성하고, parameter mapping 하고, 개발자마다 indent도 다 다르게 작성하는 엄청난 양의 쿼리를 개발만 하고 떠났다.
- 실제로 파라미터 mapping 하는 과정에서의 디버깅도 상당히 오래 걸린다.
- paging or 동적 쿼리도 쿼리 문자열 중간중간 수 많은 if문으로 되어있다.
- 운영하는 입장에서 봤을때, 지옥 그 자체다.
- 현재 진행하고 있는 프로젝트에서는 jpa를 사용했다.
- 기본적인 쿼리들이 모두 객체로 model화 되어, class 와 repository로 관리되니, be 소스 자체에 쿼리가 많이 줄어든 느낌이다.
- 개발하는 시간도 현저히 줄어들었다. 이게 가장 큰 이점이라고 생각한다.
- 하지만, 잘 모르고 사용하다보니, update 하나 날리는데 두번의 쿼리가 나가고... jdbc를 사용했으면, 하나의 쿼리로 가능한데, 여러번의 쿼리를 날리게되는 과정을 거쳤다...
- 그래서 프로젝트 진행하면서, jpa를 최적화 관련한 사항을 정리 해두려고한다.

### 변경된것만 update?

- jpa는 기본적으로 하나의 필드라도, 변경감지가 되면, model의 모든 필드를 update한다.
- db에 보내는 데이터 전송량이 많아진다.
- 하지만, 변경감지로 인해 모든 필드를 Update하기때문에 수정쿼리가 항상 같다. 그러므로 db는 한번 파싱된 쿼리를 재사용하는 이점이 있다.
- 수정된 데이터만 동적으로 update 하고 싶다면, model 에 @DynamicUpdate를 붙여주면 된다.

### 내부조인? 외부조인

- 부끄럽게도, 프로젝트 중반에 알게된 내용이다.
- 연관관계를 설정하고, eager 로딩을 할 경우, nullable = false 로 해주지 않으면, jpa 는 기본적으로 Left 조인을 한다.

```java
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(..., nullable = false)

// Or
@ManyToOne(fetch = FetchType.EAGER, optional = false)
@JoinColumn(...)
```

- 이렇게되면, 원하지 않은 join이 되어, null column을 가진 대상도 같이 조회 될 것이다.
- 이번 프로젝트 하면서 느끼는거지만, db 컬럼 정의부터, entity 설정까지.. 정확한 도메인 분석을 바탕으로 설계하는것이 필수다.

### JPQL 페치조인 / 글로벌 로딩 전략

- entity에 적용하는 로딩 전략은 글로벌 로딩 전략이라고 한다.
- 기본적으로 글로벌 로딩 전략으로 lazy 전략을 사용하고, 최적화가 필요한 곳에 페치 조인을 사용하는것이 합리적이다
  - 이유는, 글로벌 로딩 전략으로 eager를 사용하면, 여러 엔티티가 필요한 곳에서는 효과적일 수 있지만, 단건 조회하는 곳에서는 성능에 악영향을 미친다.

### JPQL 벌크연산 주의점

- JPQL은 일단 db에 쿼리를 날리는게 먼저다.
- 즉, JPQL 벌크연산(delete, update, insert)은 영속성 컨텍스트를 무시하고 db에 직접 쿼리한다.
- 그러므로, 벌크연산시 영속성컨텍스트에 존재하는 엔티티의 값은 변경되지 않는다.
- 결론. 벌크 연산을 수행한 후에 refresh를 하여 재조회하거나, 벌크 연산을 트랜잭션 가정 먼저 실행하거나, 벌크연산 후에 영속성 컨텍스트를 초기화(clear and flush) 해야한다.

###
